.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez plus profond√©ment dans le Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez √† des tirages au sort et √† des promotions de vacances.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _nt_mqtt_Subscribe:

6. Lecteur Cloud avec @MQTT
=========================================

Il est recommand√© de r√©aliser d'abord le projet :ref:`nt_mqtt_publish` pour installer certains modules et configurer la plateforme HiveMQ.

Dans ce projet, le Pico W agira comme un abonn√© et recevra le nom de la chanson sous le sujet d√©fini.
Si le nom de la chanson est d√©j√† dans le code, le Pico W fera jouer la chanson via le buzzer.

**1. Composants n√©cessaires**

Dans ce projet, nous aurons besoin des composants suivants. 

Il est √©videmment plus pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - √âL√âMENTS DANS LE KIT
        - LIEN
    *   - Kepler Kit	
        - 450+
        - |link_kepler_kit|

Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. list-table::
    :widths: 5 20 5 20
    :header-rows: 1

    *   - SN
        - COMPOSANT	
        - QUANTIT√â
        - LIEN

    *   - 1
        - :ref:`cpn_pico_w`
        - 1
        - |link_picow_buy|
    *   - 2
        - C√¢ble Micro USB
        - 1
        - 
    *   - 3
        - :ref:`cpn_breadboard`
        - 1
        - |link_breadboard_buy|
    *   - 4
        - :ref:`cpn_wire`
        - Plusieurs
        - |link_wires_buy|
    *   - 5
        - :ref:`cpn_transistor`
        - 1(S8050)
        - |link_transistor_buy|
    *   - 6
        - :ref:`cpn_resistor`
        - 1(1KŒ©)
        - |link_resistor_buy|
    *   - 7
        - Buzzer passif :ref:`cpn_buzzer`
        - 1
        - |link_passive_buzzer_buy|
    *   - 8
        - :ref:`cpn_lipo_charger`
        - 1
        -  
    *   - 9
        - Batterie 18650
        - 1
        -  
    *   - 10
        - Support de Batterie
        - 1
        -  

**2. Monter le Circuit**

Le kit comprend deux buzzers. Nous utilisons ici un buzzer passif (celui avec un PCB expos√© √† l'arri√®re). Le buzzer n√©cessite un transistor pour fonctionner, et nous utilisons un S8050.

    .. warning:: 
        
        Assurez-vous que votre module de chargeur Li-po est connect√© comme indiqu√© sur le sch√©ma. Sinon, un court-circuit pourrait endommager votre batterie et votre circuit.

.. image:: img/wiring/6.mqtt_sub_bb.png



**3. Ex√©cuter le Code**

#. T√©l√©chargez le fichier ``play_music.py`` sous le chemin ``kepler-kit-main/iot`` vers le Raspberry Pi Pico W.

    .. image:: img/mqtt-A-1.png

#. Ouvrez le fichier ``6_mqtt_subscribe_music.py`` dans le r√©pertoire ``kepler-kit-main/iot`` et cliquez sur le bouton **Ex√©cuter le script actuel** ou appuyez sur F5 pour l'ex√©cuter.

    .. image:: img/6_cloud_player.png

    .. note::
        Avant de lancer le code, assurez-vous d'avoir les scripts ``do_connect.py`` et ``secrets.py`` dans votre Pico W. Sinon, veuillez vous r√©f√©rer √† :ref:`iot_access` pour les cr√©er.

#. Ouvrez |link_hivemq| dans votre navigateur, remplissez le Topic avec ``SunFounder MQTT Music``, et le nom de la chanson comme **Message**. Apr√®s avoir cliqu√© sur le bouton **Publier**, le buzzer connect√© au Pico W jouera la chanson correspondante.

    .. note::
        Les chansons incluses dans ``play_music.py`` sont ``nokia``, ``starwars``, ``nevergonnagiveyouup``, ``gameofthrone``, ``songofstorms``, ``zeldatheme``, ``harrypotter``.

    .. image:: img/mqtt-5.png
        :width: 500

#. Si vous souhaitez que ce script se lance au d√©marrage, vous pouvez l'enregistrer sur le Raspberry Pi Pico W sous le nom ``main.py``.

**Comment √ßa fonctionne ?**

Pour simplifier la compr√©hension, nous avons s√©par√© le code MQTT du reste. Le r√©sultat est le code suivant, qui impl√©mente les fonctionnalit√©s de base des abonnements MQTT en trois √©tapes.

.. code-block:: python
    :emphasize-lines: 13,14,15,16,20,28,29,30

    import time
    from umqtt.simple import MQTTClient

    from do_connect import *
    do_connect()

    mqtt_server = 'broker.hivemq.com'
    client_id = 'Jimmy'

    # pour s'abonner au message
    topic = b'SunFounder MQTT Music'

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()
        
    while True:
        client.subscribe(topic)
        time.sleep(1)

Lors de la connexion au broker MQTT, nous appelons la fonction ``client.set_callback(callback)``, qui sert de rappel pour les messages re√ßus via les abonnements.

.. code-block:: python
    :emphasize-lines: 3

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()

Ensuite, la fonction de rappel affiche le message re√ßu du topic. 
MQTT est un protocole binaire o√π les √©l√©ments de contr√¥le sont des octets binaires et non des cha√Ænes de texte, donc ces messages doivent √™tre d√©cod√©s avec ``message.decode('utf-8')``.

.. code-block:: python

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

Utilisez une boucle ``While True`` pour obtenir r√©guli√®rement des messages sur ce topic.

.. code-block:: python

    while True:
        client.subscribe(topic)
        time.sleep(1)


Ensuite, la musique sera jou√©e. Cette fonction se trouve dans le script ``play_music.py`` et se compose de trois parties principales.

* ``Tone`` : Simule un ton sp√©cifique bas√© sur la fr√©quence fondamentale |link_piano_frequency|, utilis√©e pour jouer la note.

    .. code-block:: python

        NOTE_B0 =  31
        NOTE_C1 =  33
        ...
        NOTE_DS8 = 4978
        REST =      0

* ``Score`` : √âditez la musique dans un format que le programme peut utiliser. Ces partitions proviennent du `partage libre de Robson Couto <https://github.com/robsoncouto/arduino-songs>`_, vous pouvez √©galement ajouter vos morceaux pr√©f√©r√©s dans le format suivant.

    .. code-block:: python

        # notes de la m√©lodie suivies de la dur√©e.
        # un 4 signifie une noire, un 8 une croche, un 16 une double croche, etc.
        # !!les nombres n√©gatifs repr√©sentent des notes point√©es, 
        # donc -4 signifie une noire point√©e, soit une noire plus une croche !!
        song = {
            "nokia":[NOTE_E5, 8, NOTE_D5, 8, NOTE_FS4, 4, NOTE_GS4, 4, NOTE_CS5, 8, NOTE_B4, 8, NOTE_D4, 4, 
                        NOTE_E4, 4,NOTE_B4, 8, NOTE_A4, 8, NOTE_CS4, 4, NOTE_E4, 4, NOTE_A4, 2],
            "starwars":[,,,],
            "nevergonnagiveyouup":[,,,],
            "gameofthrone":[,,,],
            "songofstorms":[,,,],
            "zeldatheme":[,,,],
            "harrypotter":[,,,],
        }

* ``Play`` : Cette partie est essentiellement la m√™me que :ref:`py_pa_buz`, mais l√©g√®rement optimis√©e pour s'adapter aux partitions ci-dessus.

    .. code-block:: python

       import time
       import machine

       # changez cette valeur pour rendre la chanson plus lente ou plus rapide
       tempo = 220

       # ceci calcule la dur√©e d'une ronde en ms
       wholenote = (60000 * 4) / tempo

       def tone(pin,frequency,duration):
           if frequency is 0:
               pass
           else:
               pin.freq(frequency)
               pin.duty_u16(30000)
           time.sleep_ms(duration)
           pin.duty_u16(0)

       def noTone(pin):
           tone(pin,0,100)

       def play(pin,melody):

           # it√©rez sur les notes de la m√©lodie.
           # Rappel, le tableau contient deux fois le nombre de notes (notes + dur√©es)
           for thisNote in range(0,len(melody),2):
               # calculez la dur√©e de chaque note
               divider = melody[thisNote+1]
               if divider > 0:
                   noteDuration = wholenote/divider
               elif divider < 0:
                   noteDuration = wholenote/-(divider)
                   noteDuration *= 1.5

               # nous ne jouons la note que pour 90% de sa dur√©e, laissant 10% comme pause
               tone(pin,melody[thisNote],int(noteDuration*0.9))

               # Attendez la dur√©e sp√©cifi√©e avant de jouer la note suivante.
               time.sleep_ms(int(noteDuration))

               # arr√™tez la g√©n√©ration d'onde avant la note suivante.
               noTone(pin)

Retournez √† la fonction principale et laissez MQTT d√©clencher la lecture de la musique.
Dans la fonction de rappel, d√©terminez si le message envoy√© correspond au nom d'une chanson incluse.
Si c'est le cas, assignez le nom de la chanson √† la variable ``melody`` et d√©finissez ``play_flag`` sur ``True``.

.. code-block:: python
    :emphasize-lines: 5,6,7,8

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)
        if message in song.keys():
            global melody,play_flag
            melody = song[message]
            play_flag = True

Dans la boucle principale, si ``play_flag`` est ``True``, jouez ``melody``.

.. code-block:: python
    :emphasize-lines: 4,5,6

    while True:
        client.subscribe(topic)
        time.sleep(1)
        if play_flag is True:
            play(buzzer,melody)
            play_flag = False