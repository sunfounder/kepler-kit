.. note::

    춰Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum칠rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **쯇or qu칠 unirse?**

    - **Soporte Experto**: Resuelve problemas posventa y desaf칤os t칠cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previsualizaciones Exclusivas**: Obt칠n acceso anticipado a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m치s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones de temporada.

    游녤 쯃isto para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 칰nete hoy.
.. _nt_mqtt_Subscribe:

6. Reproductor en la Nube con @MQTT
=========================================

Se recomienda realizar primero el proyecto :ref:`nt_mqtt_publish` para completar la instalaci칩n de algunos m칩dulos y la configuraci칩n de la plataforma HiveMQ.

En este proyecto, el Pico W actuar치 como un suscriptor y recibir치 el nombre de la canci칩n en el tema correspondiente.
Si el nombre de la canci칩n ya est치 en el c칩digo, el Pico W har치 que el zumbador reproduzca la canci칩n.

**1. Componentes Requeridos**

Para este proyecto, necesitamos los siguientes componentes.

Es conveniente adquirir el kit completo; aqu칤 tienes el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Kepler	
        - 450+
        - |link_kepler_kit|

Tambi칠n puedes comprarlos por separado a trav칠s de los enlaces a continuaci칩n.

.. list-table::
    :widths: 5 20 5 20
    :header-rows: 1

    *   - N.췈
        - COMPONENTE	
        - CANTIDAD
        - ENLACE

    *   - 1
        - :ref:`cpn_pico_w`
        - 1
        - |link_picow_buy|
    *   - 2
        - Cable Micro USB
        - 1
        - 
    *   - 3
        - :ref:`cpn_breadboard`
        - 1
        - |link_breadboard_buy|
    *   - 4
        - :ref:`cpn_wire`
        - Varios
        - |link_wires_buy|
    *   - 5
        - :ref:`cpn_transistor`
        - 1(S8050)
        - |link_transistor_buy|
    *   - 6
        - :ref:`cpn_resistor`
        - 1(1K풜)
        - |link_resistor_buy|
    *   - 7
        - Zumbador Pasivo :ref:`cpn_buzzer`
        - 1
        - |link_passive_buzzer_buy|
    *   - 8
        - :ref:`cpn_lipo_charger`
        - 1
        -  
    *   - 9
        - Bater칤a 18650
        - 1
        -  
    *   - 10
        - Portapilas
        - 1
        -  

**2. Construcci칩n del Circuito**

El kit incluye dos zumbadores; utilizaremos el zumbador pasivo (el que tiene el PCB expuesto en la parte posterior). El zumbador necesita un transistor para funcionar; aqu칤 usamos el S8050.

    .. warning:: 
        
        Aseg칰rate de que el M칩dulo de Carga Li-po est칠 conectado como se muestra en el diagrama. De lo contrario, un cortocircuito podr칤a da침ar tu bater칤a y el circuito.

.. image:: img/wiring/6.mqtt_sub_bb.png



**3. Ejecuci칩n del C칩digo**

#. Sube el archivo ``play_music.py`` en la ruta ``kepler-kit-main/iot`` a la Raspberry Pi Pico W.

    .. image:: img/mqtt-A-1.png

#. Abre el archivo ``6_mqtt_subscribe_music.py`` en la ruta ``kepler-kit-main/iot`` y haz clic en el bot칩n **Run current script** o presiona F5 para ejecutarlo.

    .. image:: img/6_cloud_player.png

    .. note::
        Antes de ejecutar el c칩digo, aseg칰rate de tener los scripts ``do_connect.py`` y ``secrets.py`` en tu Pico W. Si no, consulta :ref:`iot_access` para crearlos.



#. Abre |link_hivemq| en tu navegador, llena el Tema (Topic) como ``SunFounder MQTT Music`` y coloca el nombre de la canci칩n en el **Mensaje**. Al hacer clic en el bot칩n **Publish**, el zumbador conectado al Pico W reproducir치 la canci칩n correspondiente.


    .. note::
        Las canciones incluidas en play_music.py son ``nokia``, ``starwars``, ``nevergonnagiveyouup``, ``gameofthrone``, ``songofstorms``, ``zeldatheme``, ``harrypotter``.

    .. image:: img/mqtt-5.png
        :width: 500

#. Si deseas que este script se ejecute al inicio, puedes guardarlo en la Raspberry Pi Pico W como ``main.py``.

**쮺칩mo funciona?**

Para facilitar la comprensi칩n, separamos el c칩digo de MQTT del resto.
As칤 obtienes el siguiente c칩digo, que implementa la funcionalidad b치sica de suscripciones MQTT en tres puntos clave.

.. code-block:: python
    :emphasize-lines: 13,14,15,16,20,28,29,30

    import time
    from umqtt.simple import MQTTClient

    from do_connect import *
    do_connect()

    mqtt_server = 'broker.hivemq.com'
    client_id = 'Jimmy'

    # para suscribirse al mensaje
    topic = b'SunFounder MQTT Music'

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()
        
    while True:
        client.subscribe(topic)
        time.sleep(1)


Al conectarse al broker MQTT, llamamos a la funci칩n ``client.set_callback(callback)``, que sirve como callback para los mensajes de suscripci칩n recibidos.

.. code-block:: python
    :emphasize-lines: 3

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()

Luego, la funci칩n de callback imprime el mensaje del tema que se recibi칩.
MQTT es un protocolo binario, donde los elementos de control son bytes binarios y no cadenas de texto, por lo que estos mensajes deben decodificarse con ``message.decode('utf-8')``.

.. code-block:: python

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

Usa un bucle ``While True`` para obtener mensajes bajo este tema a intervalos regulares.

.. code-block:: python

    while True:
        client.subscribe(topic)
        time.sleep(1)


A continuaci칩n, se reproducir치 la m칰sica. Esta funci칩n est치 en el script ``play_music.py``, que consta de tres partes principales.

   * ``Tone``: Simula un tono espec칤fico basado en la frecuencia fundamental |link_piano_frequency|, utilizada para reproducirlo.

        .. code-block:: python

            NOTE_B0 =  31
            NOTE_C1 =  33
            ...
            NOTE_DS8 = 4978
            REST =      0

   * ``Score``: Edita la m칰sica en un formato que el programa puede usar. Estas partituras son de `compartici칩n gratuita de Robson Couto <https://github.com/robsoncouto/arduino-songs>`_, tambi칠n puedes a침adir tu m칰sica favorita en el siguiente formato.

    .. code-block:: python

        # notas de la melod칤a seguidas de la duraci칩n.
        # un 4 significa una negra, un 8 una corchea, 16 una semicorchea, etc.
        # !!los n칰meros negativos representan notas punteadas,
        # as칤 que -4 significa una negra con puntillo!!
        song = {
            "nokia":[NOTE_E5, 8, NOTE_D5, 8, NOTE_FS4, 4, NOTE_GS4, 4, NOTE_CS5, 8, NOTE_B4, 8, NOTE_D4, 4, 
                        NOTE_E4, 4,NOTE_B4, 8, NOTE_A4, 8, NOTE_CS4, 4, NOTE_E4, 4, NOTE_A4, 2],
            "starwars":[,,,],
            "nevergonnagiveyouup":[,,,],
            "gameofthrone":[,,,],
            "songofstorms":[,,,],
            "zeldatheme":[,,,],
            "harrypotter":[,,,],
        }

    * ``Play``: Esta parte es b치sicamente la misma que :ref:`py_pa_buz`, pero ligeramente optimizada para adaptarse a la partitura anterior.

   .. code-block:: python

       import time
       import machine

       # cambia esto para hacer la canci칩n m치s lenta o r치pida
       tempo = 220

       # esto calcula la duraci칩n de una redonda en ms
       wholenote = (60000 * 4) / tempo

       def tone(pin,frequency,duration):
           if frequency is 0:
               pass
           else:
               pin.freq(frequency)
               pin.duty_u16(30000)
           time.sleep_ms(duration)
           pin.duty_u16(0)

       def noTone(pin):
           tone(pin,0,100)

       def play(pin,melody):

           # itera sobre las notas de la melod칤a.
           # Recuerda, el array es el doble de las notas (notas + duraciones)
           for thisNote in range(0,len(melody),2):
               # calcula la duraci칩n de cada nota
               divider = melody[thisNote+1]
               if divider > 0:
                   noteDuration = wholenote/divider
               elif divider < 0:
                   noteDuration = wholenote/-(divider)
                   noteDuration *= 1.5

               # solo tocamos la nota durante el 90% de la duraci칩n, dejando el 10% como pausa
               tone(pin,melody[thisNote],int(noteDuration*0.9))

               # espera la duraci칩n especificada antes de reproducir la siguiente nota.
               time.sleep_ms(int(noteDuration))

               # detiene la generaci칩n de la onda antes de la siguiente nota.
               noTone(pin)


Regresa a la funci칩n principal y permite que MQTT active la reproducci칩n de m칰sica.
En la funci칩n de callback, determina si el mensaje enviado es el nombre de una canci칩n incluida.
Si es as칤, asigna el nombre de la canci칩n a la variable ``melody`` y establece ``play_flag`` en ``True``.

.. code-block:: python
    :emphasize-lines: 5,6,7,8

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)
        if message in song.keys():
            global melody,play_flag
            melody = song[message]
            play_flag = True

En el bucle principal, si ``play_flag`` es ``True``, reproduce ``melody``.

.. code-block:: python
    :emphasize-lines: 4,5,6

    while True:
        client.subscribe(topic)
        time.sleep(1)
        if play_flag is True:
            play(buzzer,melody)
            play_flag = False