.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _nt_mqtt_Subscribe:

6. Cloud-Player mit @MQTT
=========================================

Es wird empfohlen, zun√§chst das Projekt :ref:`nt_mqtt_publish` abzuschlie√üen, um einige Module zu installieren und die Konfiguration der HiveMQ-Plattform vorzunehmen.

In diesem Projekt wird das Pico W als Abonnent fungieren und den Songtitel unter dem entsprechenden Topic empfangen. 
Falls der Songtitel bereits im Code hinterlegt ist, wird Pico W den Summer den Song spielen lassen.

**1. Ben√∂tigte Komponenten**

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten. 

Ein vollst√§ndiges Kit zu kaufen ist definitiv praktisch, hier ist der Link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Bezeichnung
        - ARTIKEL IM KIT
        - LINK
    *   - Kepler-Kit
        - 450+
        - |link_kepler_kit|

Alternativ k√∂nnen Sie die Teile auch einzeln √ºber die untenstehenden Links erwerben.

.. list-table::
    :widths: 5 20 5 20
    :header-rows: 1

    *   - SN
        - KOMPONENTE
        - ANZAHL
        - LINK

    *   - 1
        - :ref:`cpn_pico_w`
        - 1
        - |link_picow_buy|
    *   - 2
        - Micro-USB-Kabel
        - 1
        - 
    *   - 3
        - :ref:`cpn_breadboard`
        - 1
        - |link_breadboard_buy|
    *   - 4
        - :ref:`cpn_wire`
        - Mehrere
        - |link_wires_buy|
    *   - 5
        - :ref:`cpn_transistor`
        - 1(S8050)
        - |link_transistor_buy|
    *   - 6
        - :ref:`cpn_resistor`
        - 1(1KŒ©)
        - |link_resistor_buy|
    *   - 7
        - Passiver :ref:`cpn_buzzer`
        - 1
        - |link_passive_buzzer_buy|
    *   - 8
        - :ref:`cpn_lipo_charger`
        - 1
        -  
    *   - 9
        - 18650-Batterie
        - 1
        -  
    *   - 10
        - Batteriehalter
        - 1
        -  

**2. Schaltkreis aufbauen**

Im Kit sind zwei Summer enthalten, wir verwenden einen passiven Summer (einen mit freiliegender Leiterplatte auf der R√ºckseite). F√ºr den Betrieb des Summers ist ein Transistor erforderlich, hier verwenden wir S8050.

    .. warning::

        Stellen Sie sicher, dass Ihr Li-Po-Ladeger√§t wie im Diagramm gezeigt angeschlossen ist. Andernfalls k√∂nnte ein Kurzschluss sowohl Ihre Batterie als auch die Schaltung besch√§digen.

.. image:: img/wiring/6.mqtt_sub_bb.png

**3. Code ausf√ºhren**

#. Laden Sie die Datei ``play_music.py`` aus dem Pfad ``kepler-kit-main/iot`` auf das Raspberry Pi Pico W hoch.

    .. image:: img/mqtt-A-1.png

#. √ñffnen Sie die Datei ``6_mqtt_subscribe_music.py`` im Pfad ``kepler-kit-main/iot`` und klicken Sie auf die Schaltfl√§che **Aktuelles Skript ausf√ºhren** oder dr√ºcken Sie F5, um es auszuf√ºhren.

    .. image:: img/6_cloud_player.png

    .. note::

        Bevor Sie den Code ausf√ºhren, stellen Sie sicher, dass Sie die Skripte ``do_connect.py`` und ``secrets.py`` auf Ihrem Pico W haben. Wenn nicht, beziehen Sie sich bitte auf :ref:`iot_access`, um sie zu erstellen.

#. √ñffnen Sie |link_hivemq| in Ihrem Browser, geben Sie das Topic als ``SunFounder MQTT Music`` ein und den Songtitel als **Nachricht**. Nach dem Klicken auf die **Ver√∂ffentlichen**-Schaltfl√§che wird der am Pico W angeschlossene Summer den entsprechenden Song abspielen.

    .. note::

        In play_music.py sind ``nokia``, ``starwars``, ``nevergonnagiveyouup``, ``gameofthrone``, ``songofstorms``, ``zeldatheme``, ``harrypotter`` enthalten.

    .. image:: img/mqtt-5.png
        :width: 500

#. Wenn Sie m√∂chten, dass dieses Skript beim Hochfahren ausgef√ºhrt wird, k√∂nnen Sie es auf dem Raspberry Pi Pico W als ``main.py`` speichern.


**Wie funktioniert es?**

Um es einfacher zu gestalten, haben wir den MQTT-Code vom Rest des Codes separiert.
Daraus resultiert der folgende Code, der die grundlegendste Funktionalit√§t der MQTT-Abonnements an drei Stellen implementiert.

.. code-block:: python
    :emphasize-lines: 13,14,15,16,20,28,29,30

    import time
    from umqtt.simple import MQTTClient

    from do_connect import *
    do_connect()

    mqtt_server = 'broker.hivemq.com'
    client_id = 'Jimmy'

    # to subscribe the message
    topic = b'SunFounder MQTT Music'

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()
        
    while True:
        client.subscribe(topic)
        time.sleep(1)


Beim Verbindungsaufbau mit dem MQTT-Broker rufen wir die Funktion ``client.set_callback(callback)`` auf, die als R√ºckruffunktion f√ºr die empfangenen Abonnement-Nachrichten dient.

.. code-block:: python
    :emphasize-lines: 3

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()


Als n√§chstes kommt die R√ºckruffunktion, die die Nachricht aus dem abonnierten Thema ausgibt.
MQTT ist ein bin√§rbasiertes Protokoll, bei dem die Steuerelemente bin√§re Bytes und keine Textzeichenfolgen sind. Daher m√ºssen diese Nachrichten mit ``message.decode('utf-8')`` dekodiert werden.

.. code-block:: python

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

Verwenden Sie eine ``While True``-Schleife, um regelm√§√üig Nachrichten unter diesem Thema zu erhalten.

.. code-block:: python

    while True:
        client.subscribe(topic)
        time.sleep(1)

Als n√§chstes wird Musik abgespielt. Diese Funktion befindet sich im Skript ``play_music.py``, das aus drei Hauptteilen besteht.

   * ``Tone``: Simuliert einen spezifischen Ton basierend auf der Grundfrequenz |link_piano_frequency|, der zum Abspielen verwendet wird.

        .. code-block:: python

            NOTE_B0 =  31
            NOTE_C1 =  33
            ...
            NOTE_DS8 = 4978
            REST =      0

   * ``Score``: Bearbeiten Sie die Musik in ein f√ºr das Programm nutzbares Format. Diese Partituren stammen von `Robson Coutos kostenloser Weitergabe <https://github.com/robsoncouto/arduino-songs>`_, Sie k√∂nnen auch Ihre Lieblingsmusik im folgenden Format hinzuf√ºgen.

    .. code-block:: python

        # notes of the moledy followed by the duration.
        # a 4 means a quarter note, 8 an eighteenth , 16 sixteenth, so on
        # !!negative numbers are used to represent dotted notes,
        # so -4 means a dotted quarter note, that is, a quarter plus an eighteenth!!
        song = {
            "nokia":[NOTE_E5, 8, NOTE_D5, 8, NOTE_FS4, 4, NOTE_GS4, 4, NOTE_CS5, 8, NOTE_B4, 8, NOTE_D4, 4, 
                        NOTE_E4, 4, NOTE_B4, 8, NOTE_A4, 8, NOTE_CS4, 4, NOTE_E4, 4, NOTE_A4, 2],
            "starwars":[,,,],
            "nevergonnagiveyouup":[,,,],
            "gameofthrone":[,,,],
            "songofstorms":[,,,],
            "zeldatheme":[,,,],
            "harrypotter":[,,,],
        }

    * ``Play``: Dieser Teil ist im Grunde genommen das gleiche wie :ref:`py_pa_buz`, aber leicht optimiert, um zur obigen Partitur zu passen.

   .. code-block:: python

       import time
       import machine

       # change this to make the song slower or faster
       tempo = 220

       # this calculates the duration of a whole note in ms
       wholenote = (60000 * 4) / tempo

       def tone(pin,frequency,duration):
           if frequency is 0:
               pass
           else:
               pin.freq(frequency)
               pin.duty_u16(30000)
           time.sleep_ms(duration)
           pin.duty_u16(0)

       def noTone(pin):
           tone(pin,0,100)

       def play(pin,melody):

           # iterate over the notes of the melody.
           # Remember, the array is twice the number of notes (notes + durations)
           for thisNote in range(0,len(melody),2):
               # calculates the duration of each note
               divider = melody[thisNote+1]
               if divider > 0:
                   noteDuration = wholenote/divider
               elif divider < 0:
                   noteDuration = wholenote/-(divider)
                   noteDuration *= 1.5

               # we only play the note for 90% of the duration, leaving 10% as a pause
               tone(pin,melody[thisNote],int(noteDuration*0.9))

               # Wait for the specief duration before playing the next note.
               time.sleep_ms(int(noteDuration))

               # stop the waveform generation before the next note.
               noTone(pin)


Zur√ºck zur Hauptfunktion und lassen Sie MQTT die Musikwiedergabe ausl√∂sen.
In der R√ºckruffunktion √ºberpr√ºfen Sie, ob die gesendete Nachricht der Name eines enthaltenen Liedes ist.
Falls ja, weisen Sie den Liednamen der Variable ``melody`` zu und setzen ``play_flag`` auf ``True``.

.. code-block:: python
    :emphasize-lines: 5,6,7,8

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)
        if message in song.keys():
            global melody,play_flag
            melody = song[message]
            play_flag = True

In der Hauptschleife wird, wenn ``play_flag`` auf ``True`` gesetzt ist, ``melody`` abgespielt.

.. code-block:: python
    :emphasize-lines: 4,5,6

    while True:
        client.subscribe(topic)
        time.sleep(1)
        if play_flag is True:
            play(buzzer,melody)
            play_flag = False
