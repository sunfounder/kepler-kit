.. note::

    ¡Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sumérgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte Experto**: Resuelve problemas posventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previsualizaciones Exclusivas**: Obtén acceso anticipado a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos más recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones de temporada.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy.
.. _nt_mqtt_Subscribe:

6. Reproductor en la Nube con @MQTT
=========================================

Se recomienda realizar primero el proyecto :ref:`nt_mqtt_publish` para completar la instalación de algunos módulos y la configuración de la plataforma HiveMQ.

En este proyecto, el Pico W actuará como un suscriptor y recibirá el nombre de la canción en el tema correspondiente.
Si el nombre de la canción ya está en el código, el Pico W hará que el zumbador reproduzca la canción.

**1. Componentes Requeridos**

Para este proyecto, necesitamos los siguientes componentes.

Es conveniente adquirir el kit completo; aquí tienes el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Kepler	
        - 450+
        - |link_kepler_kit|

También puedes comprarlos por separado a través de los enlaces a continuación.

.. list-table::
    :widths: 5 20 5 20
    :header-rows: 1

    *   - N.º
        - COMPONENTE	
        - CANTIDAD
        - ENLACE

    *   - 1
        - :ref:`cpn_pico_w`
        - 1
        - |link_picow_buy|
    *   - 2
        - Cable Micro USB
        - 1
        - 
    *   - 3
        - :ref:`cpn_breadboard`
        - 1
        - |link_breadboard_buy|
    *   - 4
        - :ref:`cpn_wire`
        - Varios
        - |link_wires_buy|
    *   - 5
        - :ref:`cpn_transistor`
        - 1(S8050)
        - |link_transistor_buy|
    *   - 6
        - :ref:`cpn_resistor`
        - 1(1KΩ)
        - |link_resistor_buy|
    *   - 7
        - Zumbador Pasivo :ref:`cpn_buzzer`
        - 1
        - |link_passive_buzzer_buy|
    *   - 8
        - :ref:`cpn_lipo_charger`
        - 1
        -  
    *   - 9
        - Batería 18650
        - 1
        -  
    *   - 10
        - Portapilas
        - 1
        -  

**2. Construcción del Circuito**

El kit incluye dos zumbadores; utilizaremos el zumbador pasivo (el que tiene el PCB expuesto en la parte posterior). El zumbador necesita un transistor para funcionar; aquí usamos el S8050.

    .. warning:: 
        
        Asegúrate de que el Módulo de Carga Li-po esté conectado como se muestra en el diagrama. De lo contrario, un cortocircuito podría dañar tu batería y el circuito.

.. image:: img/wiring/6.mqtt_sub_bb.png



**3. Ejecución del Código**

#. Sube el archivo ``play_music.py`` en la ruta ``kepler-kit-main/iot`` a la Raspberry Pi Pico W.

    .. image:: img/mqtt-A-1.png

#. Abre el archivo ``6_mqtt_subscribe_music.py`` en la ruta ``kepler-kit-main/iot`` y haz clic en el botón **Run current script** o presiona F5 para ejecutarlo.

    .. image:: img/6_cloud_player.png

    .. note::
        Antes de ejecutar el código, asegúrate de tener los scripts ``do_connect.py`` y ``secrets.py`` en tu Pico W. Si no, consulta :ref:`iot_access` para crearlos.



#. Abre |link_hivemq| en tu navegador, llena el Tema (Topic) como ``SunFounder MQTT Music`` y coloca el nombre de la canción en el **Mensaje**. Al hacer clic en el botón **Publish**, el zumbador conectado al Pico W reproducirá la canción correspondiente.


    .. note::
        Las canciones incluidas en play_music.py son ``nokia``, ``starwars``, ``nevergonnagiveyouup``, ``gameofthrone``, ``songofstorms``, ``zeldatheme``, ``harrypotter``.

    .. image:: img/mqtt-5.png
        :width: 500

#. Si deseas que este script se ejecute al inicio, puedes guardarlo en la Raspberry Pi Pico W como ``main.py``.

**¿Cómo funciona?**

Para facilitar la comprensión, separamos el código de MQTT del resto.
Así obtienes el siguiente código, que implementa la funcionalidad básica de suscripciones MQTT en tres puntos clave.

.. code-block:: python
    :emphasize-lines: 13,14,15,16,20,28,29,30

    import time
    from umqtt.simple import MQTTClient

    from do_connect import *
    do_connect()

    mqtt_server = 'broker.hivemq.com'
    client_id = 'Jimmy'

    # para suscribirse al mensaje
    topic = b'SunFounder MQTT Music'

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()
        
    while True:
        client.subscribe(topic)
        time.sleep(1)


Al conectarse al broker MQTT, llamamos a la función ``client.set_callback(callback)``, que sirve como callback para los mensajes de suscripción recibidos.

.. code-block:: python
    :emphasize-lines: 3

    try:
        client = MQTTClient(client_id, mqtt_server, keepalive=60)
        client.set_callback(callback)
        client.connect()
        print('Connected to %s MQTT Broker'%(mqtt_server))
    except OSError as e:
        print('Failed to connect to MQTT Broker. Reconnecting...')
        time.sleep(5)
        machine.reset()

Luego, la función de callback imprime el mensaje del tema que se recibió.
MQTT es un protocolo binario, donde los elementos de control son bytes binarios y no cadenas de texto, por lo que estos mensajes deben decodificarse con ``message.decode('utf-8')``.

.. code-block:: python

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)

Usa un bucle ``While True`` para obtener mensajes bajo este tema a intervalos regulares.

.. code-block:: python

    while True:
        client.subscribe(topic)
        time.sleep(1)


A continuación, se reproducirá la música. Esta función está en el script ``play_music.py``, que consta de tres partes principales.

   * ``Tone``: Simula un tono específico basado en la frecuencia fundamental |link_piano_frequency|, utilizada para reproducirlo.

        .. code-block:: python

            NOTE_B0 =  31
            NOTE_C1 =  33
            ...
            NOTE_DS8 = 4978
            REST =      0

   * ``Score``: Edita la música en un formato que el programa puede usar. Estas partituras son de `compartición gratuita de Robson Couto <https://github.com/robsoncouto/arduino-songs>`_, también puedes añadir tu música favorita en el siguiente formato.

    .. code-block:: python

        # notas de la melodía seguidas de la duración.
        # un 4 significa una negra, un 8 una corchea, 16 una semicorchea, etc.
        # !!los números negativos representan notas punteadas,
        # así que -4 significa una negra con puntillo!!
        song = {
            "nokia":[NOTE_E5, 8, NOTE_D5, 8, NOTE_FS4, 4, NOTE_GS4, 4, NOTE_CS5, 8, NOTE_B4, 8, NOTE_D4, 4, 
                        NOTE_E4, 4,NOTE_B4, 8, NOTE_A4, 8, NOTE_CS4, 4, NOTE_E4, 4, NOTE_A4, 2],
            "starwars":[,,,],
            "nevergonnagiveyouup":[,,,],
            "gameofthrone":[,,,],
            "songofstorms":[,,,],
            "zeldatheme":[,,,],
            "harrypotter":[,,,],
        }

    * ``Play``: Esta parte es básicamente la misma que :ref:`py_pa_buz`, pero ligeramente optimizada para adaptarse a la partitura anterior.

   .. code-block:: python

       import time
       import machine

       # cambia esto para hacer la canción más lenta o rápida
       tempo = 220

       # esto calcula la duración de una redonda en ms
       wholenote = (60000 * 4) / tempo

       def tone(pin,frequency,duration):
           if frequency is 0:
               pass
           else:
               pin.freq(frequency)
               pin.duty_u16(30000)
           time.sleep_ms(duration)
           pin.duty_u16(0)

       def noTone(pin):
           tone(pin,0,100)

       def play(pin,melody):

           # itera sobre las notas de la melodía.
           # Recuerda, el array es el doble de las notas (notas + duraciones)
           for thisNote in range(0,len(melody),2):
               # calcula la duración de cada nota
               divider = melody[thisNote+1]
               if divider > 0:
                   noteDuration = wholenote/divider
               elif divider < 0:
                   noteDuration = wholenote/-(divider)
                   noteDuration *= 1.5

               # solo tocamos la nota durante el 90% de la duración, dejando el 10% como pausa
               tone(pin,melody[thisNote],int(noteDuration*0.9))

               # espera la duración especificada antes de reproducir la siguiente nota.
               time.sleep_ms(int(noteDuration))

               # detiene la generación de la onda antes de la siguiente nota.
               noTone(pin)


Regresa a la función principal y permite que MQTT active la reproducción de música.
En la función de callback, determina si el mensaje enviado es el nombre de una canción incluida.
Si es así, asigna el nombre de la canción a la variable ``melody`` y establece ``play_flag`` en ``True``.

.. code-block:: python
    :emphasize-lines: 5,6,7,8

    def callback(topic, message):
        print("New message on topic {}".format(topic.decode('utf-8')))
        message = message.decode('utf-8')
        print(message)
        if message in song.keys():
            global melody,play_flag
            melody = song[message]
            play_flag = True

En el bucle principal, si ``play_flag`` es ``True``, reproduce ``melody``.

.. code-block:: python
    :emphasize-lines: 4,5,6

    while True:
        client.subscribe(topic)
        time.sleep(1)
        if play_flag is True:
            play(buzzer,melody)
            play_flag = False