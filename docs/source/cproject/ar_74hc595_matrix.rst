.. _ar_74hc_788bs:

5.4 - 8x8 ピクセルグラフィックス
=================================

EDマトリックスは低解像度のドットマトリックスディスプレイです。これは、パターン表示のためのピクセルとして発光ダイオード（LED）の配列を使用します。

これらは屋外の日光でも十分に明るく見え、店舗、広告看板、標識、そして公共交通機関の可変メッセージディスプレイ（例えばバスや電車など）でよく見られます。

このキットでは、16ピンを持つ8x8ドットマトリックスが使用されています。アノードは行に、カソードは列に接続されており（回路レベルで）、これらの64個のLEDをまとめて制御します。

最初のLEDを点灯させるには、Row1に高レベルを、Col1に低レベルを供給する必要があります。2つ目のLEDを点灯させるには、Row1に高レベル、Col2に低レベルを供給すればよく、以降も同様です。
行と列の各ペアに流れる電流を制御することで、各LEDは個々に文字や画像を表示するために制御できます。

* :ref:`cpn_dot_matrix`
* :ref:`cpn_74hc595`

**必要な部品**

このプロジェクトで必要な部品は以下の通りです。

一式を購入するのが確実に便利です、そのリンクはこちらです：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットに含まれるアイテム
        - 購入リンク
    *   - Kepler Kit
        - 450以上
        - |link_kepler_kit|

以下のリンクから個々に購入することも可能です。

.. list-table::
    :widths: 5 20 5 20
    :header-rows: 1

    *   - SN
        - コンポーネントの説明
        - 個数
        - 購入リンク

    *   - 1
        - :ref:`cpn_pico_w`
        - 1
        - |link_picow_buy|
    *   - 2
        - Micro USBケーブル
        - 1
        - 
    *   - 3
        - :ref:`cpn_breadboard`
        - 1
        - |link_breadboard_buy|
    *   - 4
        - :ref:`cpn_wire`
        - 数本
        - |link_wires_buy|
    *   - 5
        - :ref:`cpn_dot_matrix`
        - 1
        - 
    *   - 6
        - :ref:`cpn_74hc595`
        - 2
        - |link_74hc595_buy|

**回路図**

|sch_ledmatrix|

この8x8ドットマトリックスは、2つの74HC595チップによって制御されています。1つは行を、もう1つは列を制御しています。また、これら2つのチップはG18~G20を共有しており、これによりPico WボードのI/Oポートを大幅に節約できます。

Pico Wは一度に16ビットの2進数を出力する必要があります。最初の8ビットは行を制御する74HC595に、残りの8ビットは列を制御する74HC595に与えられ、このようにしてドットマトリックスは特定のパターンを表示できます。

Q7': シリーズ出力ピンで、複数の74HC595をシリーズ接続するために別の74HC595のDSに接続されます。


**配線**

回路を組み立てましょう。配線が複雑なので、ステップバイステップで進めます。

**ステップ1:** まず、Pico W、LEDドットマトリックス、および2つの74HC595チップをブレッドボードに挿入します。Pico Wの3.3VとGNDをボードの両側の穴に接続し、2つの74HC595チップのpin16とpin10をVCCに、pin13とpin8をGNDに接続します。

.. note::
   上のFritzing画像では、ラベルがある側は下です。

|wiring_ledmatrix_4|

**ステップ2:** 2つの74HC595のpin11を接続し、次にGP20に接続します。次に、2つのチップのpin12をGP19に接続します。次に、左側の74HC595のpin14をGP18に、pin9を2つ目の74HC595のpin14に接続します。

|wiring_ledmatrix_3|

**ステップ3:** 右側の74HC595は、LEDドットマトリックスの列を制御するためです。以下の表でマッピングを参照してください。したがって、74HC595のQ0-Q7ピンはそれぞれ、pin13、3、4、10、6、11、15、および16とマッピングされます。

+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **74HC595**        | **Q0** | **Q1** | **Q2** | **Q3** | **Q4** | **Q5** | **Q6** | **Q7** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **LED Dot Matrix** | **13** | **3**  | **4**  | **10** | **6**  | **11** | **15** | **16** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+

|wiring_ledmatrix_2|

**ステップ4:** 今度はLEDドットマトリックスのROWを接続します。左側の74HC595がLEDドットマトリックスのROWを制御します。以下の表でマッピングを参照してください。Q0-Q7の74HC595はそれぞれ、pin9、14、8、12、1、7、2、5とマッピングされます。

+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **74HC595**        | **Q0** | **Q1** | **Q2** | **Q3** | **Q4** | **Q5** | **Q6** | **Q7** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **LED Dot Matrix** | **9**  | **14** | **8**  | **12** | **1**  | **7**  | **2**  | **5**  |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+

|wiring_ledmatrix_1|

**コード**

.. note::
   * ファイル ``5.4_8x8_pixel_graphics.ino`` を ``kepler-kit-main/arduino/5.4_8x8_pixel_graphics`` のパスで開くことができます。
   * または、このコードを **Arduino IDE** にコピペしてください。

   * ボード（Raspberry Pi Pico）と正確なポートを選択したら、 **Upload** ボタンをクリックする前に忘れずに設定してください。

.. raw:: html
    
    <iframe src=https://create.arduino.cc/editor/sunfounder01/b3682592-17d4-4690-a730-1c0a6fcbd353/preview?embed style="height:510px;width:100%;margin:10px 0" frameborder=0></iframe>

プログラムが実行されると、8x8ドットマトリックスに「X」グラフィックが表示されます。

**動作原理**

ここでは2つの74HC595を使用して、ドットマトリックスの行と列に信号を供給します。
信号の供給方法は前の章の ``shiftOut()`` と同じですが、ここでは一度に16ビットの2進数を書き込む必要があります。

メインループは ``shiftOut()`` を2回呼び出し、2つの8ビットの2進数を書き込んでバスに出力します。これにより、特定のパターンが表示されます。

ただし、ドットマトリックス内のLEDは共通の極を使用しているため、複数の行/列を同時に制御すると互いに干渉します（例えば、(1,1)と(2,2)が同時に点灯すると、(1,2)と(2,1)も必然的に点灯します）。
したがって、一度に1つの列（または1つの行）を活性化し、8回のサイクルを行い、残像原理を使用して人間の目で8つのパターンをマージさせる必要があります。

.. code-block:: arduino

   for(int num = 0; num <=8; num++)
   {
      digitalWrite(STcp,LOW); //ground ST_CP and hold low for as long as you are transmitting
      shiftOut(DS,SHcp,MSBFIRST,datArray[num]);
      shiftOut(DS,SHcp,MSBFIRST,0x80>>num);    
      //return the latch pin high to signal chip that it 
      //no longer needs to listen for information
      digitalWrite(STcp,HIGH); //pull the ST_CPST_CP to save the data
   }

この例では、メイン関数は ``for`` ループをネストしています。 ``i`` が1のとき、最初の行だけが活性化され（制御ラインのチップが ``0x80`` の値を取得し）、最初の行の画像が書き込まれます。
``i`` が2のとき、2行目が活性化され（制御ラインのチップが ``0x40`` の値を取得し）、2行目の画像が書き込まれます。これを8回繰り返して出力を完了します。

ちなみに、4桁の7セグメントディスプレイと同様に、人間の目によるちらつきを防ぐためにリフレッシュレートを維持する必要があり、メインループ内の余分な ``sleep()`` はできるだけ避けるべきです。

**もっと学ぶ**

``datArray`` を以下の配列に置き換えて、どのような画像が表示されるか試してみてください！

.. code-block:: arduino

   int datArray1[] = {0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF};
   int datArray2[] = {0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF};
   int datArray3[] = {0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF};
   int datArray4[] = {0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF};
   int datArray5[] = {0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF};
   int datArray6[] = {0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF};

または、独自のグラフィックを描いてみてください。
